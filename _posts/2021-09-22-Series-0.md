---
layout: post
title: Series 0 - Spike Ball
---
<div class="SeriesHeader">
<i>Growth & Decay | Explosions & Implosions | Sphere Morphology.</i>
</div>

<br>

<video class="seriesOverviewVideo" height="600" autoplay="autoplay" controls loop >
  <source type="video/mp4" src="/assets/vids/SpikeBall 0.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>

<br>

<div class="SeriesData">
<span> Minted: <i id="0numMint"></i>/<i id="0maxMint"></i> </span>
<br>
<span> Current price: <i id="0ethPrice"></i>  ETH </span>
<br>
<span> Paused to purchases: <i id="0pauseStatus"></i></span>
<br>
<span> Permanently locked: <i id="0lockStatus"></i> (it is impossible for anyone to change the number of tokens that can be minted or update the code stored.)</span>
<br>
<br>
<i id="connectWalletSign">Connect wallet to see up to date info about the series.</i>
</div>
<br>

<div align="center">
  <button id="0purchase" class="button-general purchaseButton">Purchase</button>
</div>

<div align="center" class="visualizeDiv">
  <span>Purchase made. Congratulations!</span>

  <br> <br>

  Your art piece will be added to the site shortly and a video file of it uploaded to IPFS.

  <br> <br>

  In the meantime, there are 3 steps to visualize your newly minted artwork yourself (it is too computationally expensive to be rendered in the browser). (Also don't refresh this page!):

  <br> <br>

  1. Download Processing version 3.5.4 on a computer: <a href="https://github.com/processing/processing/releases/download/processing-0270-3.5.4/processing-3.5.4-macosx.zip" target="_blank" rel="noopener noreferrer">Mac Download</a>, <a href="https://github.com/processing/processing/releases/download/processing-0270-3.5.4/processing-3.5.4-windows64.zip" target="_blank" rel="noopener noreferrer">Windows Download</a>. <a href="https://processing.org/download" target="_blank" rel="noopener noreferrer"> General Processing download site</a>.
<br> <br>
  2. Copy and paste the code for this series which is permanently hosted on the blockchain:
<br>
  <code class="language-java" id="Series0-CodeLocation0">
  Placeholder code
  </code>
<br>
<br>

  3. Paste at the top line <code>randomSeed=</code> your unique random seed: <i id="0tokenSeed">Seed placeholder</i>

</div>
<br>

With nine different parameters set from a hash combining your wallet address, the token ID and attributes of the block it is minted on (the block difficulty and time), every spike ball is unique. In fact, as a conservative estimate, there are over six million possible variations. The features that vary for each ball include:

* Growth probability - Each point that is selected has a probability for growing or decaying. This probability is biased in a particular, random direction. There is a \~30% of the ball shrinking on average and five general categories: fast growth, medium growth, equilibrium, medium decay, fast decay.
* Ball size - How large the radius of the ball is. There are roughly three categories: small, medium, large.
* Ball number of vertices - The ball can have a high or low number of vertices on its surface that can grow or decay. This changes the amount of complexity that can exist on the ball's surface.
* Ball vertices selected - Perlin noise (noise that is correlated) is used to choose which vertices to grow/decay. This randomly set parameter determines how correlated these vertices are. There are roughly ten categories of selection varying from being very sparse to highly distributed.
* Ball colour - The ball's surface colour. 256 possible red, green and blue values are randomly chosen. We can simplify the colour spectrum by categorizing these as the seven primary rainbow colours.
* Ball stroke colour - Same as above but the stroke colours connecting each vertex.
* Background colour - The background of the scene.
* Lighting colour - The colour of a light that adds contrast to the ball.
* Ball Rotation - Two rotational axes and their speeds are randomly sampled. There are roughly nine categories of rotation, ranging from none to very fast along both axes.

Using this lower bound approximation there are at least 5\*3\*2\*10\*7\*7\*7\*7\*9=6,482,700 variations.

# Gallery
#### (Click any piece to see its video & details)
<div id="tokenGallery">
  {% for item in site.data.works %}

    <div class="tokenGalleryItem">
    <a href="{{ item[1]["link"] | prepend: "/works"}}" class="tokenGalleryLink">{{ item[0] }}
    <img width="500"  src="/assets/thumbnails/{{item[0]}}.png">
    <br>
    </a>
    </div>

  {% endfor %}
</div>
# Code Explanation:

### Summary:
A mesh in the shape of a sphere is created out of lots of small triangles. A subset of the triangle points are selected to morph. In morphing, each of these points flips a biased coin to see if it grows or decays and by how much. The bias of the coin is determined by a random number unique to each ball.

The subset of points selected to morph are chosen using Perlin (correlated) noise that leads to the uneven clumping of growth/decay on the surface.  This process is repeated for a fixed number of iterations before freezing, returning to its starting state, and repeating again on an infinite loop. The videos displayed on this site each capture two of these loops.

### Details:
An [icosphere (or geodesic polyhedron)](https://en.wikipedia.org/wiki/Geodesic_polyhedron) is created by first creating a icosahedron and resizing each point to exist on an [L2-norm](https://mathworld.wolfram.com/L2-Norm.html) unit sphere. The icosahedron is converted into a sphere by choosing points that exist mid way between every current triangle and splitting them into new triangles. This is the only method that can be used to create a sphere that has a uniform distribution of triangles along its mesh. See [this tutorial](https://sinestesia.co/blog/tutorials/python-icospheres/) for great diagrams and descriptions of the process.

When the sphere is built, at each iteration we: (i) select 5% of all vertices using [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise) such that the points are somewhat correlated. (ii) Sample a growth/decay probability for each point and use this to multiply its vector position by a re-scaled amount of this probability.

In order to encourage a winner-takes-all approach where the spikes that grow the most first stay the largest, we make it harder for the smaller vertices to catch up by reducing the overall growth probability as a function of the largest vector size.

For high growth probabilities it is possible for the spikes to grow out of view. We keep track of the L2-norm of each vector and if a vector of max size tries to grow further it is prevented from doing so.

This whole process is repeated until the defined number of iterations when the result is frozen, before returning to its original state and restarting with the same parameters but slightly different results because the random number generator is not reset.
