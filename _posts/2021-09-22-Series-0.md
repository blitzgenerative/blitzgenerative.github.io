---
layout: post
title: Series 0 - Spike Ball
---
<div class="SeriesHeader">
<i>Growth & Decay | Explosions & Implosions | Sphere Morphology.</i>
</div>

<br>

<video class="seriesOverviewVideo" height="600" autoplay="autoplay" controls loop >
  <source type="video/mp4" src="/assets/vids/SpikeBall 0.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>

<br>

<div class="SeriesData">
<span> Minted: <i id="0numMint"></i>/<i id="0maxMint"></i> </span>
<br>
<span> Current price: <i id="0ethPrice"></i>  ETH </span>
<br>
<span> Paused to purchases: <i id="0pauseStatus"></i></span>
<br>
<span> Permanently locked: <i id="0lockStatus"></i></span>
<br>
<br>
<i id="connectWalletSign">Connect wallet to see up to date info about the series.</i>
</div>
<br>

<div align="center">
  <button id="0purchase" class="button-general purchaseButton">Purchase</button>
</div>

<div align="center" class="visualizeDiv">
  <span>Purchase made. Congratulations!</span>

  <br> <br>

  Your art piece will be added to the site shortly and a video file of it uploaded to IPFS.

  <br> <br>

  In the meantime, there are 3 steps to visualize your newly minted artwork yourself (it is too computationally expensive to be rendered in the browser):

  <br> <br>

  1. Download Processing on a computer: <a href="https://github.com/processing/processing/releases/download/processing-0270-3.5.4/processing-3.5.4-macosx.zip" target="_blank" rel="noopener noreferrer">Mac Download</a>, <a href="https://github.com/processing/processing/releases/download/processing-0270-3.5.4/processing-3.5.4-windows64.zip" target="_blank" rel="noopener noreferrer">Windows Download</a>. <a href="https://processing.org/download" target="_blank" rel="noopener noreferrer"> General Processing download site</a>.
<br> <br>
  2. Copy and paste the code for this series which is permanently hosted on the blockchain:
<br>
  <code class="language-java" id="Series0-CodeLocation0">
  Placeholder code
  </code>
<br>
<br>

  3. Paste at the top line <code>randomSeed=</code> your unique random seed: <i id="0tokenSeed">Seed placeholder</i>

</div>
<br>

With nine different parameters set from a hash combining your wallet address, the token ID and attributes of the block it is minted on (the block difficulty and time), every spike ball is unique. In fact, as a conservative estimate, there are over six million possible variations. The features the vary for each ball include:

* Growth probability - Each point that is selected has a probability for growing or decaying. This probability is biased in a particular direction. There is a \~30% of the ball shrinking on average and five general categories: fast growth, medium growth, equilibrium, medium decay, fast decay.
* Ball size - How large the radius of the ball is. There are roughly three categories: small, medium, large.
* Ball number of vertices - The ball can have a high or low density of vertices that can grow or decay.
* Ball vertices selected - Perlin noise (noise that is correlated) is used to choose which vertices to grow/decay. This randomly set parameter determines how correlated these vertices are. There are roughly ten groups of selection degree from being very sparse to highly distributed.
* Ball colour - The surface colour of the ball. 256 possible red, green and blue values are randomly chosen. We can simplify by categorizing these as the seven primary rainbow colours.
* Ball stroke colour - Same as above but the stroke colours connecting each vertex.
* Background colour - The background of the scene.
* Lighting colour - The colour of a light that adds contrast to the ball.
* Ball Rotation - Two rotational axes and their speeds are randomly sampled. There are roughly nine categories of rotation, ranging from none to very fast along both axes.
- Using this lower bound approximation there are at least 5*3*2*10*7*7*7*7*9=6,482,700 variations.

# Gallery

{% for item in site.data.works %}
  <li class="token-item">

    <div align="center">
      <em> <a href="{{ item[1]["link"] | prepend: "/works"}}">{{ item[0] }}</a> </em>
      <img width="500"  src="/assets/thumbnails/{{item[0]}}.png">
      <br>

    </div>

  </li>
{% endfor %}

# Code Explanation:

### Summary:
A sphere mesh is created out of lots of triangles. A  subset of the triangle points are selected to morph. In morphing, each of these points flips a biased coin to see if it grows or decays and by how much. The bias in the coin is determined by the unique piece's probability of growth/decay. The subset of points selected to morph are chosen using Perlin (correlated) noise that leads to the uneven clumping of growth/decay that can be seen.  This process is repeated for a fixed number of iterations before freezing, returning to its starting state, and repeating again on an infinite loop.

### Details:
An [icosphere (or geodesic polyhedron)](https://en.wikipedia.org/wiki/Geodesic_polyhedron) is created by first creating a icosahedron and resizing each point to exist on an [L2-norm](https://mathworld.wolfram.com/L2-Norm.html) unit sphere. The icosahedron is converted into a sphere by choosing points that exist mid way between every current triangle and splitting them into new triangles. This is the only method that can be used to create a sphere that has a uniform distribution of triangles along its mesh. See [this tutorial](https://sinestesia.co/blog/tutorials/python-icospheres/) for great diagrams and descriptions of the process. When the sphere is built, at each iteration we: (i) select 5% of all vertices using [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise) such that the points are somewhat correlated. For each point we sample a growth/decay probability and use this to multiply the vector position by a scaled amount of this probability. For high growth probabilities it is possible for the spikes to grow out of view. We keep track of the L2-norm of each vector and if a vector of max size tries to grow further it is prevented from doing so. In order to encourage a winner-takes-all approach where the spikes that grow the most first stay the largest, we make it harder for the smaller vertices to catch up by reducing the overall growth probability as a function of the largest vector size. This is repeated until the defined number of iterations when the result is frozen before returning to its original state and restarting with the same growth parameters but slightly different results.
